<!DOCTYPE html>
<html>
<head>
    <title>Anarchy Chess</title>
    <meta name="description" content="A massive multiplayer chess board with slightly bent rules. Here be anarchy.">
    <meta name="keywords" content="chess anarchy game multiplayer online">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <div id="board">
        <!-- Parent element that contains all canvases -->
    </div>

    <div class="hud game-title">
        <p>Anarchy Chess</p>
    </div>

    <div class="hud game-actions">
        <p>Chat</p>
        <p>Settings</p>
        <p>Help</p>
    </div>
    
    <div id="mainMenu" class="menu main-menu">
        <h1>Anarchy Chess</h1>
        <p>A massive multiplayer chess board, with multiple gamemodes and slightly bent rules. Here be anarchy.</p>
        <p>Choose a piece</p>
        <div class="scroll-picker" id="sc"
            onwheel="scroll({ left: event.deltaY + this.scrollLeft, top: 0, behavior: 'smooth' })"
            onclick="
                this.current = this.querySelector('[selected]');
                if (current != null) current.removeAttribute('selected');
                event.target.setAttribute('selected', true);
            ">
            <div selected>Pawn<img src="Assets/pawn.svg"></div>
            <div>Bishop<img src="Assets/bishop.svg"></div>
            <div>Knight<img src="Assets/knight.svg"></div>
            <div>Rook<img src="Assets/rook.svg"></div>
            <div>Queen<img src="Assets/queen.svg"></div>
            <div>King<img src="Assets/king.svg"></div>
        </div>
        <div style="flex-grow: 1;"></div>
        <div>Choose a colour</div>
        <div style="flex-grow: 1;"></div>
        <div class="dual-options" onclick="
                this.current = this.querySelector('[selected]');
                if (current != null) current.removeAttribute('selected');
                event.target.setAttribute('selected', true);
            ">
            <div class="black-white" style="color: white; background-color: black;">Black</div>
            <div class="black-white" style="color: black; background-color: white;">White</div>
        </div>
        <div style="flex-grow: 1;"></div>
        <input value="Play" type="button" onclick="
            mainMenu.style.display = 'none';
            spawnMenu.style.display = 'flex';
        ">
        <div style="flex-grow: 1;"></div>
    </div>

    <div id="spawnMenu" style="display: none;" class="menu spawn-menu">
        <h2>Choose your spawn location</h2>
        <div class="dual-options">
            <input value="Spawn by friend" type="button">
            <input value="Random location" type="button">
        </div>
    </div>
</body>
<script>
    // Board width = tile width * columns
    let TILE_HEIGHT = 64
    let TILE_WIDTH = 64
    let ROWS = 8
    let COLUMNS = 8
    let CANVASES = []

    const serverPackets = {
        // Info sent only to the player
        Canvases: 0,
        Token: 1,

        // Relayed information from other clients
        Move: 2,
        Spawn: 3,
        Death: 4,
        Chat: 5,
        
        // Actions and responses
        RejectMove: 6,
        RejectSpawn: 7,
        RejectChat: 8,
        FriendRequest: 9,
        FriendAdded: 10,
        FriendRemoved: 11,
        FriendsOnline: 12
    }

    const clientPackets = {
        Spawn: 0,
        Move: 1,
        Chat: 2,
        RequestFriend: 3,
        AcceptFriend: 4
    }

    const pieceType = {
        Bishop: 0,
        King: 1,
        Knight: 2,
        Pawn: 3,
        Queen: 4,
        Rook: 5
    }

    const pieceColour = {
        White: 0,
        Black: 1
    }

    const piecePaths = []
</script>
<script>
    let ws = null
    let map = null

    function Map(boardsRows, boardsColumns, pieceRows, pieceColumns) { 
        this.boards = []
        this.boardsRows = boardsRows
        this.boardsColumns = boardsColumns

        // Fill board array
        for (let x = 0; x < boardsColumns; x++) {
            this.boards[x] = []

            for (let y = 0; y < boardsRows; y++) {
                this.boards[x][y] = new Board(pieceRows, pieceColumns)
            }
        }
    }

    function Board(pieceRows, pieceColumns) {
        this.pieces = []
        this.pieceRows = pieceRows
        this.pieceColumns = pieceColumns

        for (let x = 0; x < pieceColumns; x++) {
            this.pieces[x] = []
        }
    }

    function Piece(type, colour) {
        this.type = type
        this.colour = colour
    }

    function connect(address) {
        ws = new WebSocket(address)

        ws.onmessage = ({data}) => {
            switch (data[0]) {
                case serverPackets.Canvases:                   
                    let boardsRows, boardsColumns, pieceRows, pieceColumns
                    [boardsRows, boardsColumns, pieceRows, pieceColumns] = data.slice(1)

                    board.style.width = (COLUMNS * TILE_WIDTH * boardsColumns) + "px"
                    board.style.height = (ROWS * TILE_HEIGHT * boardsRows) + "px"
                    
                    map = new Map(boardsRows, boardsColumns, pieceRows, pieceColumns)

                    let pieceArray = data.slice(5)
                    for (let i = 0; i < pieceArray.length; i += 6) {
                        let mapRow, mapColumn, boardRow, boardColumn, type, colour 
                        [mapRow, mapColumn, boardRow, boardColumn, type, colour] = pieceArray.slice(i, i + 6)
                        
                        // Add piece to board at right place, piece type is at index 4, colour is at index 5 
                        map.boards[mapRow][mapColumn].pieces[boardRow][boardColumn] = new Piece(type, colour)
                    }

                    createAllCanvases()
                    break
                case serverPackets.Move:
                    break
                case serverPackets.Reject:
                    break
                case serverPackets.RemovePiece:
                    break
                case serverPackets.RemovePiece:
                    break
                case serverPackets.AddPiece:
                    break
                case serverPackets.Chat:
                    break
                /*
                case serverPackets.FriendRequest:
                    break
                case serverPackets.FriendAdded:
                    break
                case serverPackets.FriendRemoved:
                    break
                case serverPackets.FriendsOnline:
                    break
                */
            }
        }
        
        ws.onclose = (event) => {

        }
    }

    function createAllCanvases() {
        for (let mapX = 0; mapX < map.boardsColumns; mapX++) {
            for (let mapY = 0; mapY < map.boardsRows; mapY++) {
                let el = document.createElement("canvas")
                el.width = TILE_WIDTH * COLUMNS
                el.height = TILE_HEIGHT * ROWS
                el.style.left = (el.width * mapX) + "px"
                el.style.top = (el.width * mapY) + "px"
                el.setAttribute("row", mapY)
                el.setAttribute("column", mapX)

                board.appendChild(el)
            }
        }

        board.querySelectorAll("canvas")
            .forEach(canvas => drawCheckeredBackground(canvas))
    }

    function drawPieces(mapRow, mapColumn) {
        const canvas = board.querySelector(`[row="${mapRow}"][column="${mapColumn}"]`)
        const ctx = canvas.getContext("2d", { alpha: false })
        const virtualBoard = map.boards[mapRow][mapColumn]

        let type = 1
        ctx.fillStyle = type == 1 ? "white" : "black"

        let pieceImage = new Image()
        pieceImage.src = "data:image/svg+xml;base64, " + window.btoa(piecePaths[type])
        ctx.drawImage(pieceImage, 100, 100, TILE_WIDTH, TILE_HEIGHT)
    }

    function drawCheckeredBackground(canvas) {
        const ctx = canvas.getContext("2d", { alpha: false })
        const blockWidth = canvas.width / 8
        const blockHeight = canvas.height / 8

        ctx.fillStyle = "white"
        ctx.fillRect(0, 0, canvas.width, canvas.height)
        
        let shift = false
        for (let row = 0; row < ROWS; row++) {
            for (let column = 0; column < COLUMNS; column++) {
                if (column % 2 != 0) continue

                let x = (column + shift) * blockWidth
                let y = row * blockHeight
                let gradientBlack = ctx.createLinearGradient(x, y, x + blockWidth, y + blockHeight)

                gradientBlack.addColorStop(0, "#3C3C3C")
                gradientBlack.addColorStop(1, "black")
                ctx.fillStyle = gradientBlack
                ctx.fillRect(x, y, blockWidth, blockHeight)
            }

            shift = !shift
        }
    }

    let piecePathWorker = new Worker("piecePathWorker.js")
    piecePathWorker.onmessage = (event) => piecePaths.push(event.data)

    connect(localStorage.address || "wss://server.poemanthology.org:8083")
</script>
</html>
